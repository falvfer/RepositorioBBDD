/*Tabla profesores con check y default*/
create table profesoresA (
	id_profesor d_id generated by default as identity,
    nif d_nif not null,
    nombre d_cadena60,
    poblacion d_cadena40 default 'Antequera'
);

-- Poner que id_profesor es una pk
alter table profesoresA add constraint pk_profesoresA primary key (id_profesor);

-- Poner que nif tiene que ser único
alter table profesoresA add constraint u_profesoresA1 unique (nif);

-- Prueba de default en población
insert into profesoresA (nif, nombre)
	values ('111', 'Julia');
commit;

select * from profesoresA;

-- Puedes ponerselo a null manualmente
insert into profesoresA (nif, nombre, poblacion)
	values ('112', 'Luisa', null);
commit;

select * from profesoresA;

-- Añadir el check que dice que el DNI tiene que estar formado entre 4 y 8 números
alter table profesoresA add constraint ck_profesoresA_1 check (nif similar to '[0-9]{4,8}');

-- Ya el NIF tiene restrinciones y no se puede añadir uno de 3 números
insert into profesoresA (nif, nombre)
	values ('1113', 'Vicente'); -- '113' daría error
commit;

select * from profesoresA;

/*Crear la tabla profesoresB sin check ni default. Se va a simular el autonumérico*/
create table profesoresB (
	id_profesor d_id not null,
    nif d_nif not null,
    nombre d_cadena60,
    poblacion d_cadena40
);

drop table profesoresB;

-- Poner que id_profesor es una pk
alter table profesoresB add constraint pk_profesoresB primary key (id_profesor);

-- Poner que nif tiene que ser único
alter table profesoresB add constraint u_profesoresB1 unique (nif);

-- Trigger para controlar el autonumérico, se va a implementar usando una secuencia
create sequence profesoresB_id;

set term ^;
create trigger bi_profesoresb_01
active
before insert
on PROFESORESB
as
begin

	if (new.id_profesor is NULL) THEN
    	new.id_profesor = next value for profesoresB_id;

END^
set term ;^

-- Trigger para poner la poblacion por defecto a 'Antequera'
set term ^;
create trigger bi_profesoresb_02
active
before insert
on PROFESORESB
as
begin

	if (new.poblacion is NULL) THEN
    	new.poblacion = 'Antequera';

END^
set term ;^

insert into profesoresb (nif, nombre)
	values('333333', 'Peter');
commit;

select * from profesoresb;

-- Creamos una excepcion de DNI_INCORRECTO para lo siguiente
create exception DNI_INCORRECTO 'El DNI no es valido: Debe tener entre 4 y 8 numeros';

-- Trigger como check: DNI debe tener entre 4 y 8 números
set term ^;
create trigger bi_profesoresb_03
active
before insert
position 0 -- Cambiar el orden para que se ejecute antes,
		   -- pero por defecto es 0, así que se deben cambiar los demas
on PROFESORESB
as
begin

	if (new.nif not similar to '[0-9]{4,8}') THEN
		exception DNI_INCORRECTO;

END^
set term ;^

-- No deja insertar con un NIF incorrecto
insert into profesoresb (nif, nombre)
	values('33', 'MariCarmen');
commit;

-- Sí deja insertar, pero, por problemas de orden,
-- se ha insertado saltando un id por el fallo de antes.
insert into profesoresb (nif, nombre)
	values('23223', 'MariCarmen');
commit;

select * from profesoresb;

/*Prueba de ejecución de varios triggers sobre la misma sentencia con distinta
posicion - prioridad - orden de ejecución*/
create table profe (
	nombre d_cadena60 not null,
    posicion d_entero default 0,
    numero d_entero default 0
);

-- Primer Trigger
set term ^;
create trigger bi_profe_01
before insert
position 1
on profe
as
begin
	new.posicion = 1;
    new.numero = new.numero + 1;
end^
set term ;^

-- Segundo Trigger
set term ^;
create trigger bi_profe_02
before insert
position 1
on profe
as
begin
	new.posicion = 2;
    new.numero = new.numero + 1;
end^
set term ;^

-- Va alfabéticamente cuando la posición es la misma
insert into profe (nombre)
	values ('Vicente');
commit;

insert into profe (nombre)
	values ('Enrique');
commit;

select * from profe;

/*Impedir que se pueda borrar y cambiar el nombre al profesor Vicente*/
-- Crear las excepciones
create exception vicente_ND 'No se puede borrar a Vicente';
create exception vicente_NU 'No se puede modificar a Vicente';

-- Trigger de borrar
set term ^;
create trigger bd_profe_01
before delete
position 1
on profe
as
begin

	if (old.nombre = 'Vicente') then
    	exception vicente_ND;
        
end^
set term ;^

-- Y evitar modificar
set term ^;
create trigger bu_profe_01
before update
position 1
on profe
as
begin

	if (old.nombre = 'Vicente') then
    	exception vicente_NU;
        
end^
set term ;^

-- Prueba con Enrique
update profe
	set nombre = 'Enrique Jesus'
    where nombre = 'Enrique';
commit;

delete from profe
	where nombre starting with 'Enrique';
commit;

select * from profe;

-- Prueba con Vicente
update profe
	set nombre = 'Vicente Ramon'
    where nombre = 'Vicente';
commit;

delete from profe
	where nombre = 'Vicente';
commit;

select * from profe;

/*Borrado de los triggers de 'Vicente y construcción de un único trigger*/
drop trigger bd_profe_01;
drop trigger bu_profe_01;

-- Mezclarlo en un trigger
set term ^;
create or alter trigger bud_profe_01
before update or delete
position 1
on profe
as
begin

	if (old.nombre = 'Vicente')
    then begin
    	if (updating)
        then
    		exception vicente_NU;
        else
    		exception vicente_ND;
    end
        
end^
set term ;^

-- Prueba con Vicente
update profe
	set nombre = 'Vicente Ramon'
    where nombre = 'Vicente';
commit;

delete from profe
	where nombre = 'Vicente';
commit;

-- Pero sí se pueden añadir más Vicentes
insert into PROFE(nombre)
	values ('Vicente');
commit;

select * from profe;


/*Crear tabla articulos*/
create table articulos (
	id_articulo d_id generated by default as IDENTITY,
    descripcion d_cadena60 not null,
    precio d_dinero not null,
    unidades dentero not null,
    unidades_vendidas dentero default 0 not null,
	ventas_totales d_dinero default 0 not null
);

-- Crear la PK
alter table articulos add constraint pk_articulos
	primary key (id_articulo);

-- Crear la tabla operaciones
create table logs (
	fecha_hora timestamp not null,
    definicion_operacion varchar(200)
);

/*Construir trigger que cada vez que inserte, borre o modifique un articulo
se guarde el tipo de operacion, el nombre de la tabla y la fecha-hora en la
tabla logs*/
set term ^;
create or alter trigger aiud_articulos_01
after insert or update or delete
position 1
on articulos
as
	declare variable operacion d_cadena20 = '';
begin

	if (INSERTING) then
    	operacion = 'insercion';
    else if (updating) then
    	operacion = 'actualizacion';
    else
    	operacion = 'borrado';
        
	insert into logs (fecha_hora, definicion_operacion)
    	values (CURRENT_TIMESTAMP,
        		trim(iif(INSERTING, 'Insertado', iif(UPDATING, 'Modificado', 'Borrado')))
                || ' articulo');
    	
end^
set term ;^

-- Insertar articulos
insert into articulos(descripcion, precio, unidades)
	values('a1', 10, 2);
commit;

insert into articulos(descripcion, precio, unidades)
	values('a2', 15, 4);
commit;

-- Modificar los articulos
update articulos
	set unidades = 3
	where descripcion = 'a1';
commit;

-- Borrar los articulos
delete from articulos
	where true;
commit;

-- Comprobar los "logs"
select * from logs;

/*Crear la tabla ventas*/
create table ventas(
	id_venta d_id generated by default as IDENTITY,
    id_articulo d_id not null,
    precio d_dinero not null,
    unidades dentero not null
);

-- Crear la PK
alter table ventas add constraint PK_VENTAS
	primary key (id_venta);

-- Crear la FK
alter table ventas add constraint fk_ventas_articulos
	foreign key (id_articulo)
    references articulos (id_articulo)
    on delete no action
    on update cascade;
